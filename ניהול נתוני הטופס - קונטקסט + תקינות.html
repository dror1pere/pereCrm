/**
 * 🧠 משתנה גלובלי: FORM_CONTEXT
 *
 * 🎯 מטרת המשתנה:
 * אובייקט מרכזי לניהול כל ה-state של טופס דינאמי:
 * נתונים חיצוניים, מידע מוקדם מהשרת, מידע פנימי, ולוגיקת טופס.
 *
 * 📌 מבנה פנימי:
 * - validation       : נתונים לבדיקה (כגון כפילויות)
 * - dataSources      : רשימות תלויות (כמו מקבלי עמלה)
 * - preloaded        : מידע מהשרת (תאריך, מזהים)
 * - formType         : שם סוג הטופס
 * - local            : נתונים מקומיים שאינם רלוונטיים לטפסים אחרים
 * - schema           : אובייקט הסכמה המלאה (כולל sections)
 * - flatFields       : מפת שדות שטוחה לפי מזהי שדות
 */
const FORM_CONTEXT = {
  validation: {},
  dataSources: {},
  preloaded: {},
  formType: "",
  local: {},
  schema: null,        // ✳️ נטען ב-DOMContentLoaded מתוך תגית <script>
  flatFields: {}       // ✳️ נוצר מ־schema דרך flattenSchemaToFields
};

/**
 * 🧠 פונקציה: flattenSchemaToFields
 *
 * 🎯 מטרה:
 * המרת סכמה היררכית (מבוססת sections) למבנה שטוח של שדות לפי מזהה שדה (`id`).
 *
 * ⚠️ הנחה מוקדמת:
 * הפונקציה מניחה כי `FORM_CONTEXT.schema` קיים ותקין לפני הקריאה.
 * באחריות הקריאה לוודא זאת. אין בדיקת תקינות פנימית כאן.
 *
 * 📌 שלבי פעולה:
 * 1️⃣ מעבר על כל המקטעים (`sections`) בסכמה.
 * 2️⃣ מעבר על כל `fields` בכל מקטע.
 * 3️⃣ הוספת כל שדה חוקי (id קיים) לאובייקט שטוח.
 * 4️⃣ החזרת האובייקט השטוח לשימוש חיצוני.
 *
 * @returns {Object} - מפת שדות שטוחה לפי מזהי שדות
 */
function flattenSchemaToFields() {
  console.log("📦 [flattenSchemaToFields] ▶ התחלת המרת הסכמה למבנה שטוח");

  // שלב 1️⃣ – התחלה
  const result = {};

  // שלב 2️⃣ – מעבר על מקטעים
  FORM_CONTEXT.schema.sections.forEach(section => {
    console.log(`🔍 [2️⃣] עיבוד מקטע: '${section.title}'`);

    // שלב 3️⃣ – מעבר על השדות במקטע
    (section.fields || []).forEach(field => {
      if (field.id) {
        result[field.id] = field;
        console.log(`✅ [3️⃣] שדה '${field.id}' נוסף למבנה השטוח`);
      } else {
        console.warn("⚠️ [3️⃣] שדה ללא מזהה (id) – דילוג");
      }
    });
  });

  // שלב 4️⃣ – החזרת התוצאה
  console.log("🏁 [flattenSchemaToFields] סיום עיבוד הסכמה");
  return result;
}

/**
 * 🧠 פונקציה: attachValidatorsFromSchema
 *
 * 🎯 מטרה:
 * לחבר ולידציה חיה לכל שדה בטופס לפי הסכמה,
 * להשבית זמנית את כפתור השליחה בעת שינוי בשדה חובה,
 * לשמור על הודעות שגיאה בצורה חכמה,
 * ולהבטיח גלילה חכמה לשדה הבא בעת מעבר.
 *
 * ⚠️ הנחות מוקדמות:
 * - `FORM_CONTEXT.flatFields` קיים ותקין לפני קריאה לפונקציה.
 *
 * 📌 שלבי פעולה:
 * 1️⃣ טעינת שדות מתוך `FORM_CONTEXT.flatFields`.
 * 2️⃣ מעבר על כל שדה קלט.
 * 3️⃣ דילוג על שדות מסוג כפתור.
 * 4️⃣ בניית ולידטורים לכל שדה.
 * 5️⃣ חיבור מאזיני input, blur ו-focus:
 *    - input: ולידציה מקומית בלבד + השבתת כפתור זמנית אם חובה.
 *    - blur: ולידציה מקומית + בדיקה כללית.
 *    - focus: ניקוי הודעת שגיאה אם השדה תקין + גלילה חכמה.
 */
function attachValidatorsFromSchema() {
  console.log("🛠️ [attachValidatorsFromSchema] ▶ התחלת חיבור הולידציה מהסכמה");

  // שלב 1️⃣ – טעינת שדות שטוחים מהקונטקסט
  const flatFields = FORM_CONTEXT.flatFields;

  if (!flatFields || typeof flatFields !== "object") {
    console.error("❌ [1️⃣] flatFields לא קיים או לא תקין בקונטקסט");
    return;
  }

  // שלב 2️⃣ – מעבר על כל השדות
  Object.entries(flatFields).forEach(([fieldId, fieldSchema]) => {
    console.log(`🔍 [2️⃣] טיפול בשדה: '${fieldId}'`);

    // שלב 3️⃣ – דילוג על שדות מסוג כפתור
    const isButtonType = typeof fieldSchema.type === "string" && fieldSchema.type.includes("button");
    if (isButtonType) {
      console.log(`ℹ️ [3️⃣] דילוג על שדה כפתור '${fieldId}'`);
      return;
    }

    // שלב 4️⃣ – איתור אלמנט קלט ואלמנט הודעת שגיאה
    const field = document.getElementById(fieldId);
    const errorContainer = document.querySelector(`[data-error-for="${fieldId}"]`);
    if (!field) {
      console.warn(`⚠️ [4️⃣] השדה '${fieldId}' לא נמצא ב־DOM`);
      return;
    }

    // שלב 5️⃣ – בניית הולידטורים
    const validators = buildValidators(fieldSchema);
    if (!validators.length) {
      console.log(`ℹ️ [5️⃣] אין הולידטורים לשדה '${fieldId}'`);
      return;
    }

    // שלב 6️⃣ – חיבור מאזינים

    // 🖊️ input – ולידציה מקומית בלבד + השבתת כפתור זמנית אם מדובר בשדה חובה
    field.addEventListener("input", () => {
      const result = runValidators(field.value, validators);
      updateFieldUI(result, field, errorContainer);

      if (fieldSchema.required) {
        temporarilyDisableSubmitButton();
      }
    });

    // 🔎 blur – ולידציה מקומית + בדיקה כללית לכל הטופס
    field.addEventListener("blur", () => {
      const result = runValidators(field.value, validators);
      updateFieldUI(result, field, errorContainer);

      if (!result.valid) {
        field.focus();
      }

      validateRequiredFieldsAndToggleSubmitButton();
    });

    // 🎯 focus – ניקוי הודעת שגיאה אם השדה תקין + גלילה חכמה
    field.addEventListener("focus", () => {
      const currentValue = field.value?.trim() ?? "";
      const currentValidators = buildValidators(fieldSchema);
      const result = runValidators(currentValue, currentValidators);

      if (result.valid) {
        clearFieldError(field.id);
        console.log(`✅ [focus] שדה '${fieldId}' תקין – הודעת שגיאה נמחקה`);
      } else {
        console.log(`⚠️ [focus] שדה '${fieldId}' לא תקין – הודעת שגיאה נשארת מוצגת`);
      }

      // 🌀 גלילה חכמה לשדה
      scrollFieldIntoView(field);
    });

    console.log(`✅ [attachValidatorsFromSchema] מאזינים חוברו לשדה '${fieldId}'`);
  });

  console.log("✅ [attachValidatorsFromSchema] סיום חיבור הולידציה לכל השדות");
}


/**
 * 🧠 פונקציה: buildValidators
 *
 * 🎯 מטרה:
 * בניית מערך הולידטורים (בדיקות) לפי ההגדרות של שדה יחיד מתוך הסכמה שטוחה.
 * תומכת בסוגי ולידציה: required, minLength, regex, unique.
 *
 * 📌 שלבי פעולה:
 * 1️⃣ התחלת מערך הולידטורים ריק.
 * 2️⃣ הוספת ולידציה חובה אם נדרש (required).
 * 3️⃣ מעבר על ולידטורים נוספים שהוגדרו לשדה.
 * 4️⃣ הוספת הולידטורים מסוג minLength / regex / unique.
 * 5️⃣ החזרת המערך המוכן.
 *
 * @param {Object} fieldSchema - אובייקט של שדה יחיד מתוך סכמה שטוחה
 * @returns {Array<Object>} - מערך הולידטורים לשדה
 */
function buildValidators(fieldSchema) {
  console.log(`🧪 [buildValidators] ▶ התחלת בניית הולידטורים לשדה '${fieldSchema.id}'`);

  // שלב 1️⃣ – התחלת מערך הולידטורים
  const validators = [];

  // שלב 2️⃣ – הוספת חובה אם קיים required
  if (fieldSchema.required) {
    validators.push({
      type: "required",
      validate: val => val.trim() !== "",
      message: "שדה חובה"
    });
    console.log(`➕ [2️⃣] הולידציה required נוספה`);
  }

  // שלב 3️⃣ – מעבר על ולידטורים נוספים
  (fieldSchema.validators || []).forEach(rule => {
    switch (rule.type) {
      case "minLength":
        validators.push({
          type: "minLength",
          validate: val => val.trim().length >= rule.value,
          message: rule.message || `יש להזין לפחות ${rule.value} תווים`
        });
        console.log(`➕ [3️⃣] הולידציה minLength (${rule.value}) נוספה`);
        break;

      case "regex":
        validators.push({
          type: "regex",
          validate: val => new RegExp(rule.value).test(val),
          message: rule.message || "הערך אינו תואם לתבנית הנדרשת"
        });
        console.log(`➕ [3️⃣] הולידציה regex (${rule.value}) נוספה`);
        break;

      case "unique":
        const list = FORM_CONTEXT.validation?.[rule.list];
        if (!Array.isArray(list)) {
          console.warn(`⚠️ [3️⃣] רשימת unique '${rule.list}' אינה תקינה`);
          break;
        }
        validators.push({
          type: "unique",
          validate: val => !list.map(x => x.toLowerCase()).includes(val.trim().toLowerCase()),
          message: rule.message || "הערך כבר קיים במערכת"
        });
        console.log(`➕ [3️⃣] הולידציה unique מול רשימה '${rule.list}' נוספה`);
        break;
    }
  });

  // שלב 5️⃣ – סיום
  console.log(`✅ [buildValidators] נבנו ${validators.length} הולידטורים לשדה '${fieldSchema.id}'`);
  return validators;
}

/**
 * 🧠 פונקציה: runValidators
 *
 * 🎯 מטרה:
 * להריץ את כל הולידטורים של שדה אחד, לפי סדרם, ולהחזיר את תוצאת הבדיקה:
 * האם הערך תקין? ואם לא – איזו הודעת שגיאה להציג.
 *
 * 📌 שלבי פעולה:
 * 1️⃣ קבלת ערך לבדיקה ומערך הולידטורים.
 * 2️⃣ מעבר על כל הולידטור ברשימה.
 * 3️⃣ בדיקה מול פונקציית validate של כל הולידטור.
 * 4️⃣ עצירה על ההולידטור הראשון שנכשל.
 * 5️⃣ החזרת תוצאה מתאימה: { valid: true/false, message: string|null }
 *
 * @param {string} value - הערך של השדה לבדיקה (בדרך כלל field.value)
 * @param {Array<Object>} validators - מערך הולידטורים שהוכנו מראש ע"י buildValidators
 * @returns {Object} - אובייקט תוצאה: { valid: boolean, message: string|null }
 */
function runValidators(value, validators) {
  console.log("🔎 [runValidators] ▶ התחלת הרצת ולידציה על ערך:", value);

  try {
    // שלב 1️⃣ – ניקוי הערך
    const inputValue = value.trim();

    // שלב 2️⃣ – מעבר על הולידטורים
    for (let validator of validators) {
      // שלב 3️⃣ – הרצת פונקציית בדיקה
      const passed = validator.validate(inputValue);

      // שלב 4️⃣ – עצירה אם הבדיקה נכשלה
      if (!passed) {
        console.warn(`❌ [runValidators] כשל בוולידטור: '${validator.type}' – ${validator.message}`);
        return { valid: false, message: validator.message };
      }
    }

    // שלב 5️⃣ – אם עבר את כל הבדיקות
    console.log("✅ [runValidators] הערך עבר את כל הולידטורים בהצלחה");
    return { valid: true, message: null };

  } catch (error) {
    console.error("❌ [runValidators] שגיאה בלתי צפויה בהרצת ולידציה:", error);
    return { valid: false, message: "שגיאה לא צפויה בבדיקת שדה" };
  }
}

/**
 * 🧠 פונקציה: updateFieldUI
 *
 * 🎯 מטרה:
 * לעדכן את תצוגת השגיאה של שדה בהתאם לתוצאת הולידציה:
 * להציג הודעה במקרה של כשל, או להסיר הודעה במקרה של הצלחה.
 *
 * 📌 שלבי פעולה:
 * 1️⃣ קבלת תוצאת הולידציה, אלמנט השדה, ואלמנט השגיאה.
 * 2️⃣ אם התוצאה אינה תקינה – הצגת הודעת שגיאה.
 * 3️⃣ אם התוצאה תקינה – הסרת כל הודעת שגיאה קיימת.
 * 4️⃣ לוגים בהתאם לתוצאה.
 *
 * @param {Object} result - תוצאת הולידציה (מבנה: { valid: boolean, message: string|null })
 * @param {HTMLElement} field - אלמנט השדה ב־DOM (input / select / textarea)
 * @param {HTMLElement} errorContainer - אלמנט DOM שמיועד להציג שגיאה
 */
function updateFieldUI(result, field, errorContainer) {
  console.log(`🎨 [updateFieldUI] ▶ התחלת עדכון תצוגת שדה '${field.id}'`);

  try {
    // שלב 1️⃣ – בדיקה אם יש כשל בוולידציה
    if (!result.valid) {
      console.warn(`⚠️ [updateFieldUI] שדה '${field.id}' לא תקין – מציג הודעת שגיאה: ${result.message}`);
      showFieldError(field.id, result.message);
    } else {
      // שלב 2️⃣ – במקרה של הצלחה – הסרת הודעות שגיאה
      clearFieldError(field.id);
      console.log(`✅ [updateFieldUI] שדה '${field.id}' תקין – הודעת שגיאה הוסרה`);
    }
  } catch (error) {
    console.error(`❌ [updateFieldUI] שגיאה בעדכון UI לשדה '${field.id}':`, error);
  }
}

/**
 * 🧠 פונקציה: validateRequiredFieldsAndToggleSubmitButton
 *
 * 🎯 מטרה:
 * לבדוק האם כל שדות החובה מולאו, ולהפעיל את כפתור האישור אם כן.
 *
 * 📌 שלבי פעולה:
 * 1️⃣ טעינת מפת השדות.
 * 2️⃣ סינון שדות חובה בלבד.
 * 3️⃣ בדיקה אם כל שדה חובה מולא.
 * 4️⃣ הפעלת או השבתת כפתור האישור.
 */
function validateRequiredFieldsAndToggleSubmitButton() {
  console.log("🔎 [validateRequiredFieldsAndToggleSubmitButton] ▶ התחלת בדיקת שדות חובה");

  try {
    const flatFields = FORM_CONTEXT.flatFields;
    if (!flatFields || typeof flatFields !== "object") {
      console.error("❌ [1️⃣] flatFields לא קיים או לא תקין בקונטקסט");
      return;
    }

    const requiredFields = Object.entries(flatFields).filter(
      ([_, def]) => def.required === true
    );

    console.log(`📋 [2️⃣] נמצאו ${requiredFields.length} שדות חובה לבדיקה`);

    const allRequiredValid = requiredFields.every(([fieldId, _]) => {
      const el = document.getElementById(fieldId);
      if (!el) {
        console.warn(`⚠️ [3️⃣] שדה '${fieldId}' לא נמצא ב־DOM`);
        return true; // דילוג על שדות שלא קיימים
      }
      const value = el.value?.trim() ?? "";
      const isValid = value !== "";
      console.log(`🔍 [3️⃣] שדה '${fieldId}': ${isValid ? "✔️ מלא" : "❌ ריק"}`);
      return isValid;
    });

    const submitButton = document.getElementById("submitButton");
    if (submitButton) {
      submitButton.disabled = !allRequiredValid;
      console.log(`🔁 [4️⃣] כפתור אישור ${allRequiredValid ? "הופעל" : "הושבת"}`);
    } else {
      console.warn("⚠️ [4️⃣] כפתור 'submitButton' לא נמצא ב־DOM");
    }

  } catch (error) {
    console.error("❌ [validateRequiredFieldsAndToggleSubmitButton] שגיאה:", error);
  }
}
/**
 * 🧠 פונקציה: temporarilyDisableSubmitButton
 *
 * 🎯 מטרה:
 * להשבית זמנית את כפתור השליחה (Submit) כאשר מתבצע שינוי בשדה חובה,
 * עד אשר יושלם מילוי תקין ויאושר בבדיקה כללית.
 *
 * 📌 שלבי פעולה:
 * 1️⃣ איתור כפתור האישור לפי מזהה.
 * 2️⃣ השבתת הכפתור (disabled = true).
 * 3️⃣ הדפסת לוג לפעולה.
 */
function temporarilyDisableSubmitButton() {
  console.log("🚫 [temporarilyDisableSubmitButton] ▶ התחלת השבתת כפתור אישור זמנית");

  try {
    const submitButton = document.getElementById("submitButton");
    if (!submitButton) {
      console.warn("⚠️ [temporarilyDisableSubmitButton] כפתור Submit לא נמצא ב־DOM");
      return;
    }

    submitButton.disabled = true;
    console.log("✅ [temporarilyDisableSubmitButton] כפתור Submit הושבת בהצלחה");

  } catch (error) {
    console.error("❌ [temporarilyDisableSubmitButton] שגיאה בהשבתת כפתור:", error);
  }
}
/**
 * 🧠 פונקציה: scrollFieldIntoView
 *
 * 🎯 מטרה:
 * לגלול שדה לפוקוס רק אם הוא מחוץ לטווח הגלוי של קונטיינר הטופס (form-container),
 * ולמקם אותו באופן נעים בעין – מבלי לפגוע בראש הטופס או לגרום לקפיצות.
 *
 * 📌 שלבי פעולה:
 * 1️⃣ בדיקה שהאלמנט קיים ותקין.
 * 2️⃣ איתור קונטיינר הטופס (form-container).
 * 3️⃣ חישוב גבולות ויזואליים של השדה ביחס לקונטיינר.
 * 4️⃣ בדיקה אם השדה נמצא מעל או מתחת לגבולות הגלויים.
 * 5️⃣ גלילה רק אם נדרש, כולל מרחק בטוח מלמעלה.
 *
 * @param {HTMLElement} element - שדה שנכנס לפוקוס
 */
function scrollFieldIntoView(element) {
  console.log("🌀 [scrollFieldIntoView] ▶ התחלת גלילה חכמה לשדה");

  // שלב 1️⃣ – בדיקה ראשונית
  if (!element) {
    console.warn("⚠️ [1️⃣] אלמנט לא סופק לפונקציה – אין מה לגלול");
    return;
  }

  // שלב 2️⃣ – איתור קונטיינר
  const container = document.getElementById("form-container");
  if (!container) {
    console.error("❌ [2️⃣] קונטיינר form-container לא נמצא ב־DOM");
    return;
  }

  // שלב 3️⃣ – חישוב גבולות
  const elementRect = element.getBoundingClientRect();
  const containerRect = container.getBoundingClientRect();

  const elementTopInView = elementRect.top >= containerRect.top;
  const elementBottomInView = elementRect.bottom <= containerRect.bottom;

  console.log(`🔍 [3️⃣] שדה '${element.id}' בתוך הטווח?`, elementTopInView && elementBottomInView);

  // שלב 4️⃣ – רק אם השדה מחוץ לטווח
  if (!elementTopInView || !elementBottomInView) {
    const offsetTop = elementRect.top - containerRect.top + container.scrollTop;

    console.log(`🌀 [4️⃣] מבצע גלילה לשדה '${element.id}' (offsetTop=${offsetTop})`);

    // שלב 5️⃣ – גלילה עם מרווח נעים מלמעלה
    container.scrollTo({
      top: offsetTop - 80,
      behavior: "smooth"
    });
  } else {
    console.log(`✅ [4️⃣] השדה '${element.id}' כבר בטווח הנראה – לא נדרשת גלילה`);
  }
}
/**
 * 🧠 פונקציה: scrollToTop
 *
 * 🎯 מטרה:
 * מבצעת גלילה חלקה לתחילת הטופס בתוך הקונטיינר הראשי.
 * מאפשרת למשתמש לחזור במהירות לראש המסמך.
 *
 * 📌 שלבי פעולה:
 * 1️⃣ איתור קונטיינר הטופס לפי מזהה (form-container).
 * 2️⃣ בדיקה האם הקונטיינר קיים.
 * 3️⃣ ביצוע גלילה ל־scrollTop=0 עם התנהגות חלקה.
 * 4️⃣ רישום לוגים לאורך הפעולה.
 */
function scrollToTop() {
  console.log("🔼 [scrollToTop] ▶ התחלת גלילה לראש הטופס");

  // שלב 1️⃣ – איתור הקונטיינר
  const container = document.getElementById("form-container");

  // שלב 2️⃣ – בדיקת קיום
  if (!container) {
    console.error("❌ [scrollToTop] קונטיינר 'form-container' לא נמצא");
    return;
  }

  // שלב 3️⃣ – ביצוע הגלילה
  container.scrollTo({
    top: 0,
    behavior: "smooth"
  });

  // שלב 4️⃣ – לוג סיום
  console.log("✅ [scrollToTop] גלילה לראש הושלמה בהצלחה");
}
/**
 * 🧠 פונקציה: scrollToBottom
 *
 * 🎯 מטרה:
 * מבצעת גלילה חלקה לתחתית קונטיינר הטופס (form-container).
 * נועדה להוביל את המשתמש לכפתורי סיום כמו "אישור" ו-"ביטול".
 *
 * 📌 שלבי פעולה:
 * 1️⃣ איתור הקונטיינר לפי מזהה.
 * 2️⃣ בדיקה האם הקונטיינר קיים.
 * 3️⃣ חישוב ערך scrollTop מרבי.
 * 4️⃣ גלילה לתחתית בהתנהגות חלקה.
 * 5️⃣ רישום לוגים לאורך הדרך.
 */
function scrollToBottom() {
  console.log("🔽 [scrollToBottom] ▶ התחלת גלילה לתחתית הטופס");

  // שלב 1️⃣ – איתור הקונטיינר
  const container = document.getElementById("form-container");

  // שלב 2️⃣ – בדיקה שהקונטיינר קיים
  if (!container) {
    console.error("❌ [scrollToBottom] קונטיינר 'form-container' לא נמצא");
    return;
  }

  // שלב 3️⃣ – חישוב נקודת גלילה
  const maxScrollTop = container.scrollHeight - container.clientHeight;
  console.log(`📏 [scrollToBottom] גובה גלילה מרבי: ${maxScrollTop}`);

  // שלב 4️⃣ – ביצוע גלילה חלקה
  container.scrollTo({
    top: maxScrollTop,
    behavior: "smooth"
  });

  // שלב 5️⃣ – לוג סיום
  console.log("✅ [scrollToBottom] גלילה לתחתית הושלמה בהצלחה");
}
/**
 * 🧠 פונקציה: monitorScrollPosition
 *
 * 🎯 מטרה:
 * לעקוב אחרי מצב הגלילה בקונטיינר הטופס,
 * ולעדכן את זמינות כפתורי הגלילה (למעלה / למטה) בהתאם.
 *
 * 📌 שלבי פעולה:
 * 1️⃣ איתור האלמנטים הנדרשים
 * 2️⃣ הגדרת לוגיקה לבדיקת מיקום הגלילה
 * 3️⃣ הצמדה לאירוע גלילה
 * 4️⃣ בדיקה מיידית גם לאחר טעינה
 */
function monitorScrollPosition() {
  console.log("🧭 [monitorScrollPosition] ▶ התחלת ניטור מצב גלילה");

  // שלב 1️⃣ – איתור אלמנטים
  const container = document.getElementById("form-container");
  const upBtn = document.getElementById("scrollUpBtn");
  const downBtn = document.getElementById("scrollDownBtn");

  if (!container || !upBtn || !downBtn) {
    console.error("❌ [monitorScrollPosition] קונטיינר או כפתורים לא נמצאו ב־DOM");
    return;
  }

  // שלב 2️⃣ – פונקציה פנימית לבדיקת מצב גלילה
  const updateScrollButtons = () => {
    const scrollTop = container.scrollTop;
    const maxScrollTop = container.scrollHeight - container.clientHeight;

    const isAtTop = scrollTop <= 5;
    const isAtBottom = scrollTop >= maxScrollTop - 5;

    console.log(`📏 [monitorScrollPosition] scrollTop=${scrollTop}, max=${maxScrollTop}`);
    console.log(`🔍 מצב: isAtTop=${isAtTop}, isAtBottom=${isAtBottom}`);

    upBtn.disabled = isAtTop;
    downBtn.disabled = isAtBottom;

    console.log(`🔁 עדכון כפתורים: ⬆ upBtn.disabled=${upBtn.disabled}, ⬇ downBtn.disabled=${downBtn.disabled}`);
  };

  // שלב 3️⃣ – האזנה לאירוע scroll
  container.addEventListener("scroll", updateScrollButtons);

  // שלב 4️⃣ – בדיקה מיידית לאחר הטעינה (למקרה שכבר גולל)
  setTimeout(updateScrollButtons, 100); // השהייה קצרה כדי להבטיח render

  console.log("✅ [monitorScrollPosition] ניטור גלילה הופעל");
}
